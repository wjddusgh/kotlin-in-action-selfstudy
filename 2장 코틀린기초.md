# 2.1 기본 요소: 함수와 변수

## 함수
```kotlin
fun main(args: Array<String>) {
    println("Hell, World!!")    // Java의 System.out.println 의 wrapper로 println 제공
}
```

- **fun** : 함수 선언 키워드
- 변수 선언 뒤에 반환 타입 작성
- 줄 끝에 세미콜론(;) 생략 가능
---
```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

- 코틀린에서 if 는 **문(statement)** 이 아닌 **식(expression)** 으로 반환값이 존재
- 함수 본문이 한 줄이라면 **블록 본문** 대신 **식 본문** 으로 변환 가능

```kotlin
/*예시*/
fun max(a: Int, b: Int) = if (a > b) a else b   //함수의 리턴값 생략됨
```

-  식의 반환값을 통해 함수의 반환값을 **타입 추론(type inference)**
-  보통 블록 본문 내부에는 다양한 return 이 들어가 있기에 반환 타입 지정하도록 설계됨

## 변수
```kotlin
val answer = 42
val answer: Int = 42
val answer  // error
```
- 변수 선언시 타입 지정이 안되어 있으면 초기화 값 타입으로 컴파일러가 지정
- 초기화 식이 없다면 추론 불가, 컴파일 에러
---
변수선언 키워드|변경여부|자바 기준|
|------|---|---|
|val|   불변|final|
|var|변경가능|-|

- val 은 참조가 불변일 뿐 그 참조가 가리키는 객체의 내부 값은 메서드를 통해 변경될 수도 있다.
- var 키워드도 변수 값 변경 가능하지만, **선언 시 변수 타입이 고정**되고, 다른 타입의 값으로 변경 시 오류 발생
- var 키워드에 다른 타입의 값 넣으려면 형변환, 변환함수 등을 사용해야함

## 문자열 템플릿
자바, c++ 의 string 접합 연산 ("Hello" + name + "!") 처럼 ("Hello, **${name}**") 사용 가능
- $ 를 문자열로 사용하고 싶으면 **\(escape)** 사용
- ${변수} 대신 $변수 가능 but,
- 문자열 템플릿을 **한글**과 사용시 (ex. "$name 반가워요!") **unresolved reference** 오류 발생. 해결책은 ${변수} 사용
- ${} 의 중괄호 내부에서 **식(expression), ${}** 재사용 가능

# 2.2 클래스와 프로퍼티

```kotlin
class Person(val name: String)
```
**값 객체(value object)** : 
코드가 없이 데이터만 저장하는 클래스, 간결하게 기술할 수 있다 (default : public)
---
## 프로퍼티
```kotlin
class Person(
    val name: String,           // 읽기전용 프로퍼티, 게터 생성
    var isMarried: Boolean      // 쓸 수 있는 프로퍼티, 게터와 세터 생성
 )
 
 val person = Person("Bob", true)
 println(person.name)           
 println(person.isMarried)
 
 person.isMarried = false
```

- 코틀린은 필드와 접근자를 한데 묶은 **프로퍼티**를 **언어 기본 기능** 으로 제공
- Java 에서는 getName() 메서드를 통해 접근하지만 코틀린에서는 프로퍼티 직접 사용
- 세터 사용시에도 프로퍼티에 직접 세팅
- 게터,세터 명시적 선언을 원하면 프로퍼티 밑에 get(){ }, set(value){ } 으로 구현 가능
- 명시적 선언이 없을 시 코틀린은 내부적으로 **backing field** 사용하여 값을 저장

## 디렉터리와 패키지

```kotlin
package geometry.shapes     // 코틀린의 패키지 선언은 소스코드 맨 위에
import java.util.Random     // 자바 표준 라이브러리 클래스 임포트 가능

class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() = height == width     // 식(statement) 본문
}

fun createRandomRectangle(): Rectangle {
    val random = Random()
    return Rectangle(random.nextInt(), random.nextInt())
}
```
```kotlin
package geometry.example
import geometry.shapes.createRandomRectangle        // 함수 임포트

fun main(args: Array<String>) {
    println(createRandomRectangle().isSquare)
}
```

- 코틀린에서는 함수, 클래스 임포트에 차이가 없다.
- 자바와 다르게 여러 클래스를 한 파일에 넣을수 있고, 파일의 이름도 자유다
- 하지만 자바와 함께 사용할 경우 자바 방식을 따르는게 낫다
- 여러 클래스를 한 파일에 넣는것을 주저하지 마라( 주저할거같다)

## 선택 표현과 처리: enum과 when







